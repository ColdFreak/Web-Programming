1> string:tokens("10 4 3 + 2 * -", " ").
["10","4","3","+","2","*","-"]

下の命令はsrc/ディレクトリ下の'.erl'
ファイルとtest/ディレクトリ下の'.erl'
ファイルをコンパイルして、出力する
'.beam'ファイルをebinディレクトリに
置く
$ erlc -o ebin/ src/*.erl test/*.erl


beamファイルがどこにあるのかを
-paで指定する,テストするときに
[verbose]で指定することができる
$ erl -pa ebin/
1> eunit:test(mylist, [verbose]).

======================== EUnit ========================
module 'mylist'
  module 'mylist_tests'
    mylist_tests: sum_test...ok
    mylist_tests: product_test...ok
    mylist_tests: odds_test...ok
    [done in 0.009 s]
  [done in 0.009 s]
=======================================================
  All 3 tests passed.
ok

Binary Comprehensions
2> [X || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0].
[2,4]
3> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
4> RGB = [{R,G,B} || <<R,G,B>> <= Pixels].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
5> RGB = [{R,G,B} || <<R:8,G:8,B:8>> <= Pixels].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
6> RGB = [{R,G,B} || <<R:9,G:8,B:8>> <= Pixels].
** exception error: no match of right hand side value [{426,91,8},{257,48,129},{96,0,7}]


これはdict内部の
表現仕方，心配する
必要は無い
1> dict:new().
{dict,0,16,16,8,80,48,
      {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
	  {{[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]}}}
	

リストから辞書を作る
ことも可能, findメソッドは
Dictに探すと指定する必要
がある
2> Dict = dict:from_list([{list, 1},{tuple, 2}, {string, 3}]).
{dict,3,16,16,8,80,48,
      {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
      {{[],[],[],[],
        [[list|1]],
        [[tuple|2]],
        [],
        [[string|3]],
        [],[],[],[],[],[],[],[]}}}
3> dict:find(list, Dict).
{ok,1}
4> dict:find(string, Dict).
{ok,3}


run(Subject, RE) -> {match, Captured} | nomatch
re:run/2は上のようで，
re:run/3  run(Subject, RE, Options) -> {match, Captured} | match | nomatch
1> re:run("The quick brown fox.", "ick").
{match,[{6,3}]}
2> re:run("The quick brown fox.", "ick ").
{match,[{6,4}]}
3> re:run("The brown fox.", "ick").
nomatch
4> re:run(<<"The quick brown fox.">>, "ick").
{match,[{6,3}]}
5> re:run("The sick quick brown fox.", "ick", [global]).
{match,[[{5,3}],[{11,3}]]}

re:replace/3 returns an odd-looking binary, which
is called an iolist, an efficient data strucure,
used like this to prevent copying of data in memory
10> re:replace("The quick brown fox.", "brown", "red").
[<<"The quick ">>,<<"red">>|<<" fox.">>]

let's use re:replace/4 to provide an option
replace(Subject, RE, Replacement, Options) -> iodata() | unicode:charlist()
1> re:replace("The quick brown fox.", "brown", "red", [{return, list}]).
"The quick red fox."

It has to do something with one backslash
being consumed by the shell's parser
and the second required by the 're' module
28> re:run("4", "\\d").
{match,[{0,1}]}
34> re:run("4", "\d").
nomatch

31> re:run("a", "\\w").
{match,[{0,1}]}
32> re:run("a", "\w").
nomatch

33> re:run("Her name is Jane", "Her name is (.+)").
{match,[{0,16},{12,4}]}

14> string:words("this is a fucking good idea").
6
15> string:words("this is a fucking good idea", <).
1
16> string:words("this is a fucking good idea", $h).
2
17> string:words("this is a fucking good idea", $i).
5
18> string:join(["this", "is", "a", "string"], "W").
"thisWisWaWstring">
